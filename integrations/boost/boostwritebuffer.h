/**
 *  Support class for boost asio network operations
 * 
 *  @copyright 2014 TeamSpeak Systems GmbH
 */

#ifndef AMQP_CPP_BOOST_BOOSTWRITEBUFFER_H
#define AMQP_CPP_BOOST_BOOSTWRITEBUFFER_H

#include <vector>
#include <tuple>
#include <algorithm>
#include <boost/asio/buffer.hpp>

/**
 *  Set up namespace
 */
namespace AMQP {

/**
 *  Class definition. Boost write buffer can store several write buffers
 *  and supports sending them in one operation use scather io. This is done
 *  by the BufferAdapter class
 */
 class BoostWriteBuffer
 {
private:

	typedef std::tuple<char*, std::size_t> SingleBufferInfo;
	typedef std::vector<SingleBufferInfo> BufferContainer;
	
	/* stores all the buffers
	 * @var BufferContainer
	 */ 
	BufferContainer _buffers;
	
public:
	/**
	* constructs BoostWriteBuffer
	*
	*/
	BoostWriteBuffer()
	: _buffers()
	{}
	
	/**
	* destructs BoostWriteBuffer
	*
	*/
	~BoostWriteBuffer()
	{
		clear();
	}

	/**
	* swap contents of this object with other instance
	*
	* @param other other instance to swap with
	*/
	void swap(BoostWriteBuffer& other)
	{
		std::swap(other._buffers, _buffers);
	}
	
	/**
	* Add data to the end of the buffer
	*
	* @param data pointer to the data to add
	* @param size size of the data to add
	*/
	void append(const char* data, std::size_t size)
	{
		char* newData = new char[size];
		std::copy(data, data+size, newData);
		_buffers.push_back(SingleBufferInfo(newData, size));
	}

	/**
	 * clear all data
	 */
	void clear()
	{
		for( auto& v: _buffers)
		{
			delete [] std::get<0>(v);
		}
		_buffers.clear();
	}
	
	/**
	 * is there data in the buffer?
	 * @return bool true if there is data in the buffer
	 */
	bool hasData() const
	{
		return !_buffers.empty();
	}

	/**
	 * an adapter ment to be compatible with boost asio ConstBufferSequence
	 */
	class BufferAdapter
	{
	private:
		const BoostWriteBuffer & _destination;
	public:
		class const_iterator
		{
		private:
			const BufferContainer * _destination;
			std::size_t _position;
		
		public:
			typedef int difference_type;
			typedef boost::asio::const_buffer value_type;
			typedef boost::asio::const_buffer* pointer;
			typedef boost::asio::const_buffer& reference;
			typedef std::input_iterator_tag iterator_category;
			
			const_iterator()
			: _destination(nullptr)
			, _position()
			{}
			/**
			 * @param destination is the BufferContainer
			 * @param position is the starting position for the iterator.
			 */
			const_iterator(const BufferContainer & destination, std::size_t position)
			: _destination(&destination)
			, _position(position)
			{}
     
			const_iterator & operator ++()
			{
				if(_position < _destination->size())
				{
					++_position;
				}
				return *this;
			}

			const_iterator operator ++(int)
			{
				const_iterator result(*this);
				if(_position < _destination->size())
				{
					++_position;
				}
				return result;
			}

			boost::asio::const_buffer operator * () const
			{
				const SingleBufferInfo& item = (*_destination)[_position];
				return boost::asio::const_buffer( std::get<0>(item), std::get<1>(item));
			}

			boost::asio::const_buffer operator -> () const
			{
				const SingleBufferInfo& item = (*_destination)[_position];
				return boost::asio::const_buffer( std::get<0>(item), std::get<1>(item));
			}

			bool operator == (const const_iterator & rhs) const
			{
				return _position == rhs._position;
			}

			bool operator != (const const_iterator & rhs) const
			{
				return _position != rhs._position;
			}
			/*
			std::iterator_traits::difference_type operator-(const const_iterator& rhs ) const
			{
				return _position - rhs._position;
			}
			
			std::iterator_traits::difference_type operator-(const_iterator& rhs )
			{
				return _position - rhs._position;
			}
			*/
		private:
			const_iterator & operator=(const_iterator &); // no autogenerated assignment
		};
		
		BufferAdapter(const BoostWriteBuffer & destination)
		: _destination(destination)
		{}
  
		const_iterator begin() const
		{
			return const_iterator(_destination._buffers, 0);
		}

		const_iterator end() const
		{
			return const_iterator(_destination._buffers, _destination._buffers.size());
		}
	};
};

/**
* end namespace
*/
}

#endif //AMQP_CPP_BOOST_BOOSTWRITEBUFFER_H